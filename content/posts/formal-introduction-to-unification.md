+++
title = 'Formal Introduction to Unification'
date = 2024-03-16T16:05:13-10:00
draft = false
+++

Unification is probably one of the most important concepts in computer science. If you are not aware, unification is basically the process you undergo to find out how two syntactic objects like $a+b$ and $a+2c$ can be the same thing. In this case, you replace $b$ with $2c$. Note that you don't replace $2c$ with $b$, as $2\cdot c$ is less general than $b$, since $2\cdot c$ contains the literal $2$. 

Daniel created a language called Bergamot (https://danilafe.com/blog/bergamot/) that allows you to write expressions and unify them, while being able to see a trace of the unification process. Prolog is a very popular language that is based on unification, and belongs to the class of Logic Programming Languages. There are several projects that implement unification algorithms and give some sort of trace of the process. Though, Daniel's Bergamot is distinguished among these, as Bergamot produces a specific kind of trace called a *proof tree*. 

Proof trees can come in different forms. The kind of proof trees that Bergamot outputs are widely used in Programming Language Theory, and are the kind that I am interested in. They are generated by recursive application of inference rules (see Bergamot post) of the form
$$
\dfrac{P_1\quad \ldots \quad P_n}{Q}\ \texttt{RuleName}
$$

Show basic example of proof tree application. use < example. 

Proof trees are great explanations. But how do you make them? By hand, it is usually not so hard, since humans are generally pretty good at unification. But how does a computer do it? More precisely, how do you make a program that looks at a bunch of rules, along with a conclusion, and produces a proof tree? 

While the unification process has been formalized in many places, the process of proof tree construction has not. Here I will try to give a formal(ish) intro to proof tree generation. 







